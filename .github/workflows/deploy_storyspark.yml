name: Build/Push/Deploy image for StorySpark

on:
  workflow_dispatch:
    inputs:
      release_tag:
        description: 'Release tag (optional)'
        required: false
        default: ''

concurrency:
  group: deploy-${{ github.ref_name }}
  cancel-in-progress: false

env:
  #ACR_NAME: storysparkacr
  #ACR_LOGIN_SERVER: storysparkacr.azurecr.io
  KEEP: 2
  TF_GOOGLE_DIR: ./Portfolio/case_studies/StorySpark/src/infra/gcp
  PROJECT_ID: storyspark-555555
  GCS_BUCKET: storyspark-555555-terraform-state
  TF_PLAN_FILE: storyspark.tfplan

  # --- GitHub Variables (used via 'vars.') ---
  GCP_PROJECT_ID: ${{ vars.STORYSPARK_GCP_PROJECT_ID }}
  GCP_REGION: ${{ vars.STORYSPARK_GCP_REGION }}
  GCP_ZONE: ${{ vars.STORYSPARK_GCP_ZONE }}
  GCP_TF_STATE_BUCKET: ${{ vars.STORYSPARK_GCP_TF_STATE_BUCKET }}

  # --- GitHub Secret (used via 'secrets.') ---
  # This variable holds the JSON content of the service account key for GCP
  GCP_TERRAFORM_SA_KEY_JSON: ${{ secrets.STORYSPARK_GCP_TERRAFORM_SA_KEY }}

jobs:
  terraform-plan: # This job will run on PRs and main branch pushes to generate the plan
    runs-on: ubuntu-latest
    
    permissions:
      contents: read # Need read permission for checkout
      
    steps:
    # 1. Checkout the code
    - name: Checkout repository
      uses: actions/checkout@v4

    # 2. Authenticate to GCP using the Service Account Key Secret
    - id: 'auth'
      name: 'Authenticate to Google Cloud via SA Key'
      uses: 'google-github-actions/auth@v2'
      with:
        # Pass the secret key content directly to the action
        credentials_json: ${{ env.SA_KEY_JSON }}

    # 3. Set up Terraform
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.4.6

    # 4. Calculate the State Prefix based on the branch name
    - name: Calculate State Prefix
      id: prefix
      run: |
        # Get the branch name (e.g., 'main' or 'feature/new-api')
        BRANCH_NAME=$(echo ${{ github.ref_name }} | tr '/' '-') 
        
        # Use 'main/infra' for the main branch, otherwise use the branch name.
        if [ "$BRANCH_NAME" == "main" ]; then
          echo "tf_prefix=terraform/main/infra" >> $GITHUB_OUTPUT
        else
          echo "tf_prefix=terraform/$BRANCH_NAME/infra" >> $GITHUB_OUTPUT
        fi
      shell: bash
    
    # 5. Terraform Init - Configure GCS backend
    - name: Terraform Init
      id: init
      working-directory: ${{ env.TF_GOOGLE_DIR }}
      run: |
        # Initialize Terraform and configure the GCS backend for state locking and persistence
        terraform init \
          -backend-config="bucket=${{ env.GCP_TF_STATE_BUCKET }}" \
          -backend-config="prefix=${{ steps.prefix.outputs.tf_prefix }}"

    # 6. Terraform Plan & Save Artifact
    - name: Terraform Plan and Save
      id: plan
      working-directory: ${{ env.TF_GOOGLE_DIR }}
      run: |
        # Generate the plan and save it to a file (tfplan) for the next job
        terraform plan -out=tfplan \
          -var="project_id=${{ env.GCP_PROJECT_ID }}" \
          -var="region=${{ env.GCP_REGION }}" \
          -var="zone=${{ env.GCP_ZONE }}"
    
    # 7. Upload the generated plan file for the next job (Apply)
    - name: Upload Terraform Plan Artifact
      uses: actions/upload-artifact@v4
      with:
        name: tfplan-artifact
        path: ${{ env.TF_GOOGLE_DIR }}/tfplan

  terraform-apply: # New job: Runs only on push to 'main' and requires 'plan' to succeed
    runs-on: ubuntu-latest
    
    # 1. Dependency: This job runs only after the 'plan' job successfully completes.
    needs: [terraform-plan]
    
    # 2. Condition: This job must only run the 'main' branch.
    if: github.ref == 'refs/heads/main' 
    
    permissions:
      contents: read # Need read permission for artifact download
      
    steps:
    # 1. Checkout the code (Needed for environment consistency/context, though plan artifact has the changes)
    - name: Checkout repository
      uses: actions/checkout@v4
      
    # 2. Authenticate to GCP using the Service Account Key Secret
    - id: 'auth'
      name: 'Authenticate to Google Cloud via SA Key'
      uses: 'google-github-actions/auth@v2'
      with:
        credentials_json: ${{ env.SA_KEY_JSON }}

    # 3. Set up Terraform
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.4.6
        
    # 4. Download the generated plan file
    - name: Download Terraform Plan Artifact
      uses: actions/download-artifact@v4
      with:
        name: tfplan-artifact
        
    # 5. Calculate the State Prefix based on the branch name
    - name: Calculate State Prefix
      id: prefix
      run: |
        # Get the branch name (e.g., 'main' or 'feature/new-api')
        BRANCH_NAME=$(echo ${{ github.ref_name }} | tr '/' '-') 
        
        # Use 'main/infra' for the main branch, otherwise use the branch name.
        if [ "$BRANCH_NAME" == "main" ]; then
          echo "tf_prefix=terraform/main/infra" >> $GITHUB_OUTPUT
        else
          echo "tf_prefix=terraform/$BRANCH_NAME/infra" >> $GITHUB_OUTPUT
        fi
      shell: bash
    
    # 6. Terraform Init (required before apply to ensure backend configuration)
    - name: Terraform Init
      id: init
      working-directory: ${{ env.TF_GOOGLE_DIR }}
      run: |
        # Re-initialize to configure the GCS backend (state is needed for apply)
        terraform init \
          -backend-config="bucket=${{ env.GCP_TF_STATE_BUCKET }}" \
          -backend-config="prefix=${{ steps.prefix.outputs.tf_prefix }}"
          
    # 7. Terraform Apply the saved plan
    - name: Terraform Apply
      working-directory: ${{ env.TF_GOOGLE_DIR }}
      run: |
        # Execute the apply using the downloaded plan file
        terraform apply -auto-approve tfplan

# jobs:
#   terraform-plan:
#     name: Terraform Plan
#     runs-on: ubuntu-latest
#     permissions:
#       contents: read
#     steps:
#       - name: Checkout
#         uses: actions/checkout@v4
      
#       - name: Debug repo structure
#         run: |
#           echo "GITHUB_WORKSPACE=$GITHUB_WORKSPACE"
#           ls -R $GITHUB_WORKSPACE

#       - name: Setup Terraform
#         uses: hashicorp/setup-terraform@v2
#         with:
#           terraform_version: 1.5.7  # adjust to your required version

#       - name: Write and validate GCP service account key
#         env:
#           STORYSPARK_GCP_TERRAFORM_SA_JSON: ${{ secrets.STORYSPARK_GCP_TERRAFORM_SA_KEY }}
#         working-directory: ${{ github.workspace }}
#         run: |
#           set -euo pipefail
#           mkdir -p "${GITHUB_WORKSPACE}/.secrets"
#           printf '%s' "$STORYSPARK_GCP_TERRAFORM_SA_JSON" > "${GITHUB_WORKSPACE}/.secrets/gcp-key.json"
#           chmod 600 "${GITHUB_WORKSPACE}/.secrets/gcp-key.json"
#           jq -e . "${GITHUB_WORKSPACE}/.secrets/gcp-key.json" >/dev/null && echo "valid JSON"
#         shell: bash

#       - name: Export credentials
#         run: |
#           export GOOGLE_APPLICATION_CREDENTIALS="${{ github.workspace }}/.secrets/gcp-key.json"
#           echo "GOOGLE_APPLICATION_CREDENTIALS=${GOOGLE_APPLICATION_CREDENTIALS}" >> $GITHUB_ENV
#         shell: bash
 
#       - name: Init Terraform with GCS backend
#         working-directory: ${{ env.TF_GOOGLE_DIR }}
#         run: |
#           terraform init \
#             -backend-config="bucket=${{ env.GCS_BUCKET }}" \
#             -backend-config="prefix=terraform/state" \
#             -reconfigure
#         shell: bash

#       - name: Terraform fmt diagnostics
#         # This used to work for bootstrapworking-directory: case_studies/StorySpark/src/infra/google/bootstrap_backend
#         working-directory: ${{ env.TF_GOOGLE_DIR }}
#         run: |
#           set -euo pipefail
#           echo "Running fmt diff list"
#           terraform fmt -diff -list=true .
#           echo "Running fmt check (will exit nonâ€‘zero if issues)"
#           terraform fmt -check .
#           echo "If fmt failed, show validate and head of main.tf for parse errors"
#         shell: bash

#       - name: Write terraform.tfvars from secrets
#         working-directory: ${{ github.workspace }}/${{ env.TF_GOOGLE_DIR }}
#         run: |
#           set -euo pipefail
#           cat > terraform.tfvars <<EOF
#           project_id = "${{ vars.STORYSPARK_GCP_PROJECT_ID }}"
#           region     = "${{ vars.STORYSPARK_GCP_REGION }}"
#           zone       = "${{ vars.STORYSPARK_GCP_ZONE }}"
#           # add other variables here
#           EOF
#           chmod 600 terraform.tfvars
#         shell: bash

#       - name: Terraform plan
#         working-directory: ${{ github.workspace }}/${{ env.TF_GOOGLE_DIR }}
#         run: |
#           set -euo pipefail
#           echo "GOOGLE_APPLICATION_CREDENTIALS=$GOOGLE_APPLICATION_CREDENTIALS"; jq -e . "$GOOGLE_APPLICATION_CREDENTIALS" >/dev/null 2>&1 && echo "JSON OK" || { echo "Invalid JSON in credentials file; showing first 200 bytes:"; dd if="$GOOGLE_APPLICATION_CREDENTIALS" bs=200 count=1 2>/dev/null | sed -n '1,200p'; exit 1; }
#           echo "Checking for variables file in current directory"
#           if [ ! -f "./terraform.tfvars" ]; then
#             echo "ERROR: ./terraform.tfvars not found"
#             ls -la "./"
#             exit 1
#           fi
#           terraform plan --var-file="terraform.tfvars" -out="${{ env.TF_PLAN_FILE }}"
#         shell: bash

#       - name: Upload plan artifact
#         uses: actions/upload-artifact@v4
#         with:
#           name: tfplan
#           path: ${{ env.TF_GOOGLE_DIR }}/${{ env.TF_PLAN_FILE }}

#   terraform-apply:
#     name: Terraform Apply
#     runs-on: ubuntu-latest
#     needs: terraform-plan
#     # TODO:  Disable applying on workflow_dispatch when fully tested
#     if: github.event_name == 'workflow_dispatch' || github.ref == 'refs/heads/main'
#     permissions:
#       contents: read
#     environment:
#       name: production         # optional: requires protection rules for manual approvals
#     steps:
#       - name: Checkout
#         uses: actions/checkout@v4

#       - name: Setup Terraform
#         uses: hashicorp/setup-terraform@v2
#         with:
#           terraform_version: 1.5.7

#       - name: Download plan artifact
#         uses: actions/download-artifact@v4
#         with:
#           name: tfplan
#           path: ${{ env.TF_GOOGLE_DIR }}

#       - name: Write and validate GCP service account key
#         env:
#           STORYSPARK_GCP_TERRAFORM_SA_JSON: ${{ secrets.STORYSPARK_GCP_TERRAFORM_SA_KEY }}
#         working-directory: ${{ github.workspace }}
#         run: |
#           set -euo pipefail
#           mkdir -p "${GITHUB_WORKSPACE}/.secrets"
#           printf '%s' "$STORYSPARK_GCP_TERRAFORM_SA_JSON" > "${GITHUB_WORKSPACE}/.secrets/gcp-key.json"
#           chmod 600 "${GITHUB_WORKSPACE}/.secrets/gcp-key.json"
#           jq -e . "${GITHUB_WORKSPACE}/.secrets/gcp-key.json" >/dev/null && echo "valid JSON"
#         shell: bash

#       - name: Export credentials
#         run: |
#           export GOOGLE_APPLICATION_CREDENTIALS="${{ github.workspace }}/.secrets/gcp-key.json"
#           echo "GOOGLE_APPLICATION_CREDENTIALS=${GOOGLE_APPLICATION_CREDENTIALS}" >> $GITHUB_ENV
#         shell: bash

#       - name: Init Terraform (reconfigure)
#         working-directory: ${{ env.TF_GOOGLE_DIR }}
#         run: |
#           terraform init \
#           -backend-config="bucket=${{ env.GCS_BUCKET }}" \
#           -backend-config="prefix=terraform/state/prod" \
#           -reconfigure
#         shell: bash

#       - name: Terraform apply (apply plan artifact)
#         working-directory: ${{ env.TF_GOOGLE_DIR }}
#         run: |
#           cd "${{ env.TF_DIR }}"
#           terraform apply "${{ env.TF_PLAN_FILE }}"
#         shell: bash
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
        # build-push-deploy:
  #   runs-on: ubuntu-latest
  #   permissions:
  #     contents: read
  #     id-token: write

  #   steps:
  #     - name: Checkout
  #       uses: actions/checkout@v4

  #     - name: Set up Docker Buildx
  #       uses: docker/setup-buildx-action@v2

        # This is fetching from Github Action secrets.  The Service Principal this maps to is "github-actions-sp-storyspark" with applicationId of eb6672c3-c9cb-4bff-8bfc-3ad50520949d.  To generate a new set of credentials, use:
        # az ad sp create-for-rbac --name "github-actions-sp-storyspark" --role "Contributor" --scopes "/subscriptions/5ab40d90-e237-422e-a575-b5b73033077c" --sdk-auth
      # - name: Azure Login (service principal, from AZURE_CREDENTIALS)
      #   uses: azure/login@v1
      #   with:
      #     creds: ${{ secrets.AZURE_CREDENTIALS }}

      # - name: Log in to ACR
      #   run: az acr login --name ${{ env.ACR_NAME }}

      # - name: Set IMAGE_TAG
      #   run: echo "IMAGE_TAG=sha-${GITHUB_SHA::7}" >> "$GITHUB_ENV"

      # - name: Set IMAGE_FULL and save to file
      #   run: |
      #     set -euo pipefail
      #     echo "IMAGE_FULL=${{ env.ACR_LOGIN_SERVER }}/${{ env.IMAGE_REPO }}:${IMAGE_TAG}" >> "$GITHUB_ENV"

      # - name: Build docker image
      #   shell: bash
      #   run: |
      #     set -euo pipefail
      #     docker build -t ${ACR_LOGIN_SERVER}/${IMAGE_REPO}:${IMAGE_TAG} -f ./case_studies/StorySpark/src/docker/Dockerfile ./case_studies/StorySpark/src
      #     # keep IMAGE_FULL available for later steps

      # - name: Push docker image (only on main)
      # #   if: github.ref == 'refs/heads/main'
      #   shell: bash
      #   run: |
      #     set -euo pipefail
      #     docker push ${ACR_LOGIN_SERVER}/${IMAGE_REPO}:${IMAGE_TAG}

      # - name: Export ARM_* from AZURE_CREDENTIALS
      #   shell: bash
      #   env:
      #     AZURE_CREDENTIALS: ${{ secrets.AZURE_CREDENTIALS }}
      #   run: |
      #     clientId=$(jq -r '.clientId // .client_id // empty' <<<"$AZURE_CREDENTIALS")
      #     clientSecret=$(jq -r '.clientSecret // .client_secret // empty' <<<"$AZURE_CREDENTIALS")
      #     tenantId=$(jq -r '.tenantId // .tenant_id // empty' <<<"$AZURE_CREDENTIALS")
      #     subscriptionId=$(jq -r '.subscriptionId // .subscription_id // empty' <<<"$AZURE_CREDENTIALS")
      #     if [ -z "$clientId" ] || [ -z "$clientSecret" ] || [ -z "$tenantId" ] || [ -z "$subscriptionId" ]; then
      #       echo "Missing required fields in AZURE_CREDENTIALS"
      #       exit 1
      #     fi
      #     echo "ARM_CLIENT_ID=$clientId" >> $GITHUB_ENV
      #     echo "ARM_CLIENT_SECRET=$clientSecret" >> $GITHUB_ENV
      #     echo "ARM_TENANT_ID=$tenantId" >> $GITHUB_ENV
      #     echo "ARM_SUBSCRIPTION_ID=$subscriptionId" >> $GITHUB_ENV

      # - name: Setup Terraform
      #   uses: hashicorp/setup-terraform@v2
      #   with:
      #     terraform_version: 1.5.0

      # - name: Terraform init
      #   working-directory: ${{ env.TF_DIR }}
      #   run: terraform init -input=false

      # - name: Terraform plan
      #   working-directory: ${{ env.TF_DIR }}
      #   run: |
      #     set -euo pipefail
      #     terraform plan -input=false -var="acr_name=${{ env.ACR_NAME }}" -var="image_tag=${IMAGE_TAG}" -out=tfplan

      # - name: Terraform apply (only on main branch)
      #   if: github.ref == 'refs/heads/main'
      #   working-directory: ${{ env.TF_DIR }}
      #   run: |
      #     set -euo pipefail
      #     terraform apply -input=false -auto-approve tfplan

      # - name: Prune old images keep latest N (dry-run then delete)
      #   run: |
      #     set -euo pipefail
      #     ACR=${{ env.ACR_NAME }}
      #     REPO=${{ env.IMAGE_REPO }}
      #     KEEP=${{ env.KEEP }}
      #     # list tags newest-first
      #     tags=$(az acr repository show-tags --name "$ACR" --repository "$REPO" --orderby time_desc -o tsv)
      #     count=0
      #     echo "Dry-run: tags that would be deleted (keeping latest $KEEP):"
      #     for tag in $tags; do
      #       count=$((count+1))
      #       if [ $count -le $KEEP ]; then
      #         echo "Keeping $REPO:$tag"
      #         continue
      #       fi
      #       echo "Would delete $REPO:$tag"
      #     done

      # - name: Prune old images keep latest N (delete step -- only on main branch)
      #   if: github.ref == 'refs/heads/main'
      #   run: |
      #     set -euo pipefail
      #     ACR=${{ env.ACR_NAME }}
      #     REPO=${{ env.IMAGE_REPO }}
      #     KEEP=${{ env.KEEP }}
      #     tags=$(az acr repository show-tags --name "$ACR" --repository "$REPO" --orderby time_desc -o tsv)
      #     count=0
      #     for tag in $tags; do
      #       count=$((count+1))
      #       if [ $count -le $KEEP ]; then
      #         echo "Keeping $REPO:$tag"
      #         continue
      #       fi
      #       echo "Deleting $REPO:$tag"
      #       az acr repository delete --name "$ACR" --image "$REPO:$tag" --yes || echo "Failed to delete $REPO:$tag, continuing"
      #     done

      # - name: Smoke test endpoint
      #   if: github.ref == 'refs/heads/main'
      #   run: |
      #     set -euo pipefail
      #     url="https://storysparkapigateway.azurewebsites.net/api/books/getRecommendations"
      #     echo "Testing $url"
      #     status=$(curl -s -o /dev/null -w "%{http_code}" "$url")
      #     if [ "$status" -ne 200 ]; then
      #       echo "Smoke test failed with status $status"
      #       exit 1
      #     fi
      #     echo "Smoke test passed"
